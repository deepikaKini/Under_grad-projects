1. A Project Report on Chat Application Submitted By: Kumar Gaurav (MRT09UGBCS013)Faculty of Electronics, Informatics & Computer Engineering 2012-13
2. CERTIFICATE This is to certify that the project work under titled as Chat Application Is the bonfire work of Kumar Gaurav (MRT09UGBCS013)during this project submission as a partial fulfillment of the requirement for theSystem Design Project of Bachelor in Technology VII Semester, of the ShobhitUniversity, Meerut.Project Supervisor (C.E. Branch) H.O.D of Computer Dept.
3. ACKNOWLEDGEMENTIf words are considered as a symbol of approval and token of appreciation then letthe words play the heralding role expressing my gratitude.The satisfaction that accompanies that the successful completion of any taskwould be incomplete without the mention of people whose ceaselesscooperation made it possible, whose constant guidance and encouragementcrown all efforts with success. We are grateful to our project guide Ms. SangeetaSolanki for the guidance, inspiration and constructive suggestions that helpful us inthe preparation of this project. We also thank our colleagues who have helped insuccessful completion of the project.Kumar Gaurav
4. Table of contentsSr. No Topic Page Number 1 Introduction 05 2 System Analysis 07 2.1 Definition 07 2.2 Description of Present System 07 2.3 Limitation of Present System 07 2.4 Proposed System 08 2.5 Feasibility Study 08 2.6 Project Planning & Scheduling 11 2.7 Software Engineering Paradigm Applied 13 3 System Specification 14 3.1 H/W Specification 14 3.2 S/W Specification 15 4 Organization Profile 16 5 Specification of Language 17 6 System Design 24 6.1 Output Design 24 6.2 Input Design 25 6.3 Logical Design 25 6.4 Data Flow Diagram 26 6.5 Data Directory 32 6.6 ER Diagram 34 6.7 Process Modal 36 7 Coding 37 8 Testing 40 9 Security 42 10 Screen Shots 43 11 Future Enhancement 49 12 Conclusion 50 13 Bibliography 51
5. INTRODUCTION1. INTRODUCTIONTeleconferencing or Chatting, is a method of using technology to bring people and ideas“together” despite of the geographical barriers. The technology has been available for years butthe acceptance it was quit recent. Our project is an example of a chat server. It is made up of 2applications the client application, which runs on the user’s Pc and server application, whichruns on any Pc on the network. To start chatting client should get connected to server wherethey can practice two kinds of chatting, public one (message is broadcasted to all connectedusers) and private one (between any 2 users only) and during the last one security measureswere taken.
6. SYSTEM ANALYSIS2.1 System Objectives Communication over a network is one field where this tool finds wide ranging application.Chat application establishes a connection between 2 or more systems connected over an intra-net or ad-hoc. This tool can be used for large scale communication and conferencing in anorganization or campus of vast size, thus increasing the standard of co-operation. In addition itconverts the complex concept of sockets to a user friendly environment. This software can havefurther potentials, such as file transfer and voice chatting options that can be worked upon later.2.2 Relation to External Environment This tool helps in two major aspects -  Resolving the names of all the system connected in a network and enlisting them.  Used for communication between multiple systems enlisted in the resolved list.2.3 Design ConsiderationsApproach: The tool has been designed using C# (Windows Form Application).Methodology: The user interacts with the tool using a GUI.  The GUI operates in two forms, the List form & the chat form.  The List form contains the names of all the systems connected to a network.  The chat form makes the actual communication possible in the form of text.
7. 2.4 System ArchitectureThe chat application works in two forms.  List form: In this form, all the names of the systems connected to a network are enlisted. These names can later be used for communication with the help of mouse event, or in simple language: a click or a double click.  Chat form This form is called only when an element is selected from the List form. In this form, a connection is created between the host system and the selected system with the help of a socket.Flow Chart START List Form (List of names of systems Is name List selecte Form d Close? No No
8. Yes Yes Establish connection between Stop host and selected system Chat form (Text messages sent and received as packets Form closedYes No
9. 2.5 Operational Concepts and ScenariosOperation of the application based on the inputs given by the user:List Form:  When initialized, returns a list containing the names of all the system connected in a network.  Contains two buttons: Refresh and Connect.  When Refresh button is clicked refreshes the list of names.  When the Connect button is clicked or a name is double clicked, the chat form is initialized with a connection between the host and the client machine.  Note: If no name is selected, and connect button is clicked an error box is displayed.Chat form:  Contains a rich textbox which cannot be edited but only displays the messages from one user to another, including the self sent message, as in any chat application.  Contains a textbox for messages to be written that is sent across the network.  Contains a Send button.  When the sent button is clicked, in the background, the text in the textbox is encoded and sent as a packet over the network to the client machine. Here this message is decoded and is shown in the rich textbox.  To make it more realistic, the self sent message is shown in the rich textbox as well. Both the messages is differentiated by the help of the identifier name at the beginning of each message in the rich text box.EXIT: The user exits the software in two scenarios:  Exits the chat form, the list form remains intact.Exits the list form, this is when the application is closed.
10. SYSTEM SPECIFICATION3.1 Hardware requirementsIn hardware requirement we require all those components which will provide us the platformfor the development of the project. The minimum hardware required for the development ofthis project is as follows— Ram- minimum 128 MB Hard disk—minimum 5 GB Processor- Pentium 3 Floppy drive 1.44” inch CD driveThese all are the minimum hardware requirement required for our project. We want to makeour project to be used in any. Type of computer therefore we have taken minimumconfiguration to a large extent.128 MB ram is used so that we can execute our project in a leastpossible RAM.5 GB hard disk is used because project takes less space to be executed or stored.Therefore minimum hard disk is used. Others enhancements are according to the needs.3.2 Software requirementsSoftware’s can be defined as programs which run on our computer .it act as petrol in the vehicle.It provides the relationship between the human and a computer. It is very important to runsoftware to function the computer. Various software’s are needed in this project for itsdevelopment.Which are as follows—? Operating system—Windows 7 Others—Visual StudioWe will be using visual basic as our front hand because it is easier to use and provides features tothe users which is used for the development of the project.
11. SOFTWARE ARCHITECTURE4.1.1 Socket OverviewA socket is an object that represents a low level access point to the IP stack. This socket can beopened or closed or one of a set number of intermediate states. A socket can send and receivedata down disconnection. Data is generally sent in blocks of few kilobytes at a time forefficiency; each of these block are called a packet.All packets that travel on the internet must use the Internet Protocol. This means that thesource IP address, destination address must be included in the packet. Most packets also containa port number. A port is simply a number between 1 and 65,535 that is used to differentiatehigher protocols. Ports are important when it comes to programming your own networkapplications because no two applications can use the same port.Packets that contain port numbers come in two flavors: UDP and TCP/IP. UDP has lower latencythan TCP/IP, especially on startup. Where data integrity is not of the utmost concerned, UDP canprove easier to use than TCP, but it should never be used where data integrity is more importantthan performance; however, data sent by UDP can sometimes arrive in the wrong order and beeffectively useless to the receiver. TCP/IP is more complex than UDP and has generally longerlatencies, but it does guarantee that data does not become corrupted when travelling over theinternet. TCP is ideal for file transfer, where a corrupt file is more unacceptable than a slowdownload; however, it is unsuited to internet radio, where the odd sound out of place is moreacceptable than long gaps of silence. 4.1.2 UDP PortsThe User Datagram Protocol is an unreliable, connectionless oriented protocol that uses an IPaddress for the destination host and a port number to identify the destination application.The UDP port number is distinct from any physical port on a computer such as a COM port or anI/O port address. The UDP port is a 16-bit address that exists only for the purpose of passingcertain types of datagram information to the correct location above the transport layer of theprotocol stack.A UDP datagram header consists of four (4) fields of two bytes each: 1. source port number 2. destination port number 3. datagram size 4. checksum
12. 4.1.3 Using UDP SocketsIn order to use a UDP socket for network programming one has to follow the following steps asshown in figure given below: Create a UDP socketEnd point is a combination of IP address and port number. Endpoint objects allow you to easilyestablish and communicate over TCP/IP network connections between client and server processes,possibly residing on different hosts. The Endpoint class follows a telephone-like model of networking:clients "call" servers and servers "answer" clients. Once a network connection is established between aclient and a server, the two can "talk" to each other by reading from and writing to the connection.4.2 Software Process ModelThe Software Process Model used is the Spiral Model. The choice for this model is in the light of theenhancements that we foresee for the future. The enhancements would be in the area of Networks beingintroduced into the software.4.3 Process ModulesThe functionalities and responsibilities of the system were partitioned and then assigned
13. to subsystems or components as described below.4.3.1 Graphical User InterfaceThe user interface that the software provides to the user is interactive. It provides two different forms,one for list of systems and the other for the actual text chatting.4.3.2 Resolving NamesThis module handles the code that is necessary to view the different aspewcts of the networkconnections in a system. It uses “net.exe” to resolve the names of the system connected to a network towhich the host system is also connected. It then enlists these names into the first form of the application.4.3.3 ConnectionThis module deals with the establishment of a connection between the host system and the systemselected from the list. The connection is made by the help of sockets that uses ports to send and receivepackets from one system to another. The message sent or received is coded and is encoded or decoderespectively.4.4 ConclusionThis chapter has given a broad picture of the design of the software in terms of the different modulesused. It also gives us an idea about the degree to which each module performs related tasks. We also getan idea about the interdependence among the modules.
14. Chapter 5 System Design Detail5.1 GUI Module Name and DescriptionThis module deals with the application’s interface with the end user. All the user inputs (refreshing,connecting, chatting) are captured here.5.1.1 Design Alternatives Structured programming approach is used as the tool has been developed in Win64 platform.5.1.2 Design Details At a minimum, the following should be described - a) Processing within module
15. We develop the user interface for the application through which the user interacts with the tool. It consists of a main window and boxes which are displayed as per the menu selections made by the user. There are different controls such as edit controls, buttons etc which are used to get the user inputs. b) Error checking Errors occurring because of connection problems. Errors occurring due to incorrect input by the user.5.2 Resolving Names Module Name and DescriptionIn this module the application resolves the names of the systems connected to a network. These namesare displayed in the form of a list.5.2.1 Design Alternatives  Structured programming approach is used as the tool has been developed in Win64 platform.  Object oriented approach is an alternative to this.5.2.2 Design Details At a minimum, the following should be described
16. a)Processing within modules We provide two buttons: Refresh and Connect to the user, to provide input on the basis of selection using mouse event. This module consists of the following two sub-modules  REFRESH: This refreshes the list of names indicating to the respective systems connected in the network.  CONNECT: This connects the host system to the selected system (if any) and opens the next form with this connection. If no system is selected, then an error message is shown, which tells a user to select a system first. b) Error checking Errors occurring during file saving operations.5.2.3 Assumptions  All IP addresses fall in the same range.  Firewall is turned off for intranet.5.3 Connection Modules Names and Description In this module the user communicates with the desired user in the form of text. A connection is formedbetween the host system and the desired user with the help of sockets which itself uses ports for packetdata transfer.
17. 5.3.1 Design Alternatives Structured programming approach is used as the tool has been developed in Win64 platform. Object Oriented approach is an alternative to this.5.3.2 Design Details At a minimum, the following should be described –a) Processing within modules We show a windows form application that makes communication graphic oriented and user friendly. Three GUI interfaces are captured under this: TEXTBOX : Here the user enters the message to be sent to the remote user. RICH TEXTBOX: In this module the message sent is pasted under host name and the message received displayed under the remote users name. SEND BUTTON: When this button is pressed, the message in the textbox is displayed in the rich textbox under the host’s name and also it is sent over the network to the remote machine where it is displayed in the textbox under the sender’s name.
18. b) Error checking Errors occurring during file opening operations5.3.3 Assumptions  All IP addresses fall in the same range.  Firewall is turned off for intranet. Testing Glen Myers states a number of rules that can serve well as testing objectives. Testing is a process of executing a program with the intent of finding an error. We can test our project MNM Chat using various methods but the main objective is that when:- 1. The first form displays all the systems connected to a network correctly. 2. A successful connection is created and communication is possible via text synchronously. 6.1 TESTING OBJECTIVES: Unit testing is the testing of the individual components (units) of the software. Unit testing is conducted as part of a combined code and unit test phase of the software lifecycle, although it is not uncommon for coding and unit testing to be conducted as two distinct phases. When developing a strategy for unit testing, there are three basic organizational approaches that can be taken. These are top down, bottom up and isolation. In our case of MNM Chat we simply use top down approach. There are two sub options in our project first one is Form1 mode, which is the listing part and second one is Form2 mode which is chat box. In the first case we just test for the correct resolution of names of systems connected to a network. And in the second mode our motive is to obtain a two way communication between the host user and remote user. And we are very much successful here in our test case.
19. 6.2 Integration Testing:After the unit testing we have to perform integration testing. The goal here is to see if modules can beintegrated properly, the emphasis being on testing interfaces between modules. After the modules areconnected we have perform the total testing.6.3 SYSTEM TESTING: System testing is the process of executing software in a controlled manner, in order to answer thequestions "Does the software behave as specified?"System testing is often used in association with the terms verification and validation .Verification is thechecking of items, including software, for conformance and consistency with an associated specification.Software testing is just one kind of verification, which also uses techniques such as reviews, analysis,inspections and walkthroughs. Validation is the process of checking that what has been specified is whatthe user actually wanted. Validation: Are we doing the right job? Verification: Are we doing the job right?
20. The test strategies will include five different types of testing as describes below:-1. Logical Testing: This will be used to test every aspect of both modes, report and query as soon as it isimplemented, using valid, invalid and extreme data test data will be added to test each code module andresults compared with the expected results. Sufficient data will be added to ensure that there is at leastone entry in each category.Subsequent tests will often involved adding new data, which will be deleted when the test workssatisfactorily.As per our requirement we have also included some field such as character size etc and then querieswere performed after that results were tabulated and then the module were free from extra field.2. Functional Testing: - In this menu items were tested to ensure no functions has been missed out. Thisis done for the smooth working of the project.3. System Testing: - This is done after the completion of system; all the queries were carried out again toensure that no errors have been introduced.
21. Chapter 7 System Implementation And Maintenance7.1 Implementation
22. Implementation is a vital step in ensuring the success of new system even a well designed system can failif it is not a properly implemented. Implementation activities are needed to transform a newly developedinformation system into an operational system for end users.7.1.1 Acquiring Hardware Software And Services:These resources acquired from many sources in the computer industry. Some sources are as followsa-hardware- IBM, HP, Apple computer etc.b- software- Microsoft, Oracle etc.7.1.2 Testing:Testing of a developed system is an important implementation activity. System testing and debuggingcomputer programs and testing information processing procedures.7.1.3 Training methods:A-Vendor and in service training-Vendor offers extensive educational programs as part of their services.the courses by experiences trainers and sales personnel ,cover all aspects of using the equipment.participant actually use the system in the presence of trainer. It questions arise, they can quickly beanswered.B- In house training- It is offered by special purchased instructional materials training manuals on site.
23. 7.1.4 System documentation:Installing and operating a newly designed system or modifying an established application requires adetailed record of that system’s design. Documentation is important in diagnosing errors and makingchannel .documentation serves as a method of communication among the people responsible fordeveloping implementing and maintaining a system.7.2 Maintenance Once a system is fully implemented & being operated by end user & the maintenance function begins.System maintenance is the monitoring to evaluating &modifying of operational information system tomake desirable or necessary improvements .for example the implementation of a new system usuallyresults in the phenomenon known as the leaning curve .person who operates &use the system will makemistakes simply because the are not familiar with it .Though such errors usually diminished experience isgained with a new system ,they do point out areas where system may be improved . Maintenance is alsonecessary for the failures and problems that arise during the operation of a system .the maintenanceactivity includes a post implementation of a system review process to ensure that newly implementedsystem meet the system development objective established for them . Errors in the development of asystem must be corrected by the maintenance process .this includes a periodic review or audit of asystem to ensure on operating system &meeting its objective.
24. Chapter 8 Contribution In The ProjectA project is successfully completed only when there is contribution of all the members of a team. Eachmember in the project has a required objective to accomplish .In same way to complete this project wedivided our work in equal manner .Instead of selecting a particular task to do individually, we divided asingle task in multiple subtasks so that we all can work together on the same phase or task of the project.Doing so no team member had to wait to show his or her capabilities.
25. Chapter9 Limitation And Future Enhancement Conclusion9.1 LimitationsThere are mainly two limitations of the project and that are:
26.  The firewall is to be disabled for intra network. It is dependent on the specific algorithm used.9.2 Future Enhancement ConclusionThere is always a room for improvements in any software package, however good and efficient it may bedone. But the most important thing should be flexible to accept further modification. Right now we arejust dealing with text communication. In future this software may be extended to include features suchas:  File transfer: this will enable the user to send files of different formats to others via the chat application.  Voice chat: this will enhance the application to a higher level where communication will be possible via voice calling as in telephone.  Video chat: this will further enhance the feature of calling into video communication.
27. APPENDIX [A] Source CodeForm1.cs//Code for the first form that enlists the names://library classesusing System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Windows.Forms;using System.Diagnostics;using System.Net;using System.Net.Sockets;using System.IO;namespace Chat_App{ public partial class Form1 : Form { Form2 frm1; //object for next form
28. int portNo = 1; //ports to be used public Form1() { InitializeComponent(); }//code for resolving names on initialization private void Form1_Load(object sender, EventArgs e) { Process netUtility = new Process(); netUtility.StartInfo.FileName = "net.exe"; netUtility.StartInfo.CreateNoWindow = true; netUtility.StartInfo.Arguments = "view"; netUtility.StartInfo.RedirectStandardOutput = true; netUtility.StartInfo.UseShellExecute = false; netUtility.StartInfo.RedirectStandardError = true; netUtility.Start(); StreamReader streamReader = new StreamReader(netUtility.StandardOutput.BaseStream,netUtility.StandardOutput.CurrentEncoding); string line = ""; while ((line = streamReader.ReadLine()) != null) { if (line.StartsWith("")) { lbNames.Items.Add(line.Substring(2).Substring(0, line.Substring(2).IndexOf(" ")).ToUpper());
29. } } /* if (lbNames.ItemHeight == 0) {wwww lbNames.Items.Add("No systems connected..nPleace check LAN"); }*/ streamReader.Close(); netUtility.WaitForExit(1000); this.lbNames.MouseDoubleClick += new MouseEventHandler(lbNames_MouseDoubleClick); } private void lbNames_SelectedIndexChanged(object sender, EventArgs e) { }//refresh button private void button1_Click(object sender, EventArgs e) { lbNames.Items.Clear(); Process netUtility = new Process(); netUtility.StartInfo.FileName = "net.exe"; netUtility.StartInfo.CreateNoWindow = true; netUtility.StartInfo.Arguments = "view"; netUtility.StartInfo.RedirectStandardOutput = true; netUtility.StartInfo.UseShellExecute = false;
30. netUtility.StartInfo.RedirectStandardError = true; netUtility.Start(); StreamReader streamReader = new StreamReader(netUtility.StandardOutput.BaseStream,netUtility.StandardOutput.CurrentEncoding); string line = ""; while ((line = streamReader.ReadLine()) != null) { if (line.StartsWith("")) { lbNames.Items.Add(line.Substring(2).Substring(0, line.Substring(2).IndexOf(" ")).ToUpper()); } } /*if (lbNames.ItemHeight == 0) { * lbNames.Items.Add("No systems connected..nPleace check LAN"); }*/ streamReader.Close(); netUtility.WaitForExit(1000); }//connect button private void button2_Click(object sender, EventArgs e) { if (lbNames.SelectedItem == null) //error message box { Form3 frm = new Form3();
31. frm.Show(); } else { frm1 = new Form2(portNo, lbNames.SelectedItem.ToString()); frm1.Show(); portNo++; } } void lbNames_MouseDoubleClick(object sender, MouseEventArgs e) { int index = this.lbNames.IndexFromPoint(e.Location); if (index != System.Windows.Forms.ListBox.NoMatches) { frm1 = new Form2(portNo, lbNames.SelectedItem.ToString()); frm1.Show(); portNo++; } } }}Form 2.cs//code for the second form which is the actual chatting part//library classesusing System;
32. using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Windows.Forms;using System.Net;using System.Net.Sockets;using System.IO;using System.Threading;namespace Chat_App{ public partial class Form2 : Form { Thread thdUDPServer; int portNo; string serverName; public Form2(int port, string name) { portNo = port; serverName = name; InitializeComponent(); }
33. //thread for synchronous data transfer public void serverThread() { UdpClient udpClient = new UdpClient(portNo); while (true) { IPEndPoint RemoteIpEndPoint = new IPEndPoint(IPAddress.Any, portNo); Byte[] recieveBytes = udpClient.Receive(ref RemoteIpEndPoint); //receiving data string returnData = Encoding.ASCII.GetString(recieveBytes); lbConnections.AppendText(serverName + ":" + returnData.ToString() + "n"); } } private void Form2_Load(object sender, EventArgs e) { chatBox.Focus(); thdUDPServer = new Thread(new ThreadStart(serverThread)); //thread object for sockets thdUDPServer.Start(); } private void lbConnections_TextChanged(object sender, EventArgs e) { } private void chatBox_TextChanged(object sender, EventArgs e)
34. {}private void button1_Click(object sender, EventArgs e){ UdpClient udpClient1 = new UdpClient(); //socket object for data transfer using UDP protocol udpClient1.Connect(serverName, portNo); Byte[] sendBytes = Encoding.ASCII.GetBytes(chatBox.Text); //encoding if (chatBox.TextLength != 0) { string hostName = Dns.GetHostName().ToString(); udpClient1.Send(sendBytes, sendBytes.Length); //sending to remote user lbConnections.AppendText(hostName + ":" + chatBox.Text + "n"); lbConnections.ScrollToCaret(); } chatBox.Clear(); chatBox.Focus();}private void copyToolStripMenuItem_Click(object sender, EventArgs e){ Clipboard.Clear(); chatBox.Copy();}
35. //cut, copy, paste commandsprivate void copyToolStripMenuItem1_Click(object sender, EventArgs e) { Clipboard.Clear(); lbConnections.Copy(); } private void cutToolStripMenuItem_Click(object sender, EventArgs e) { Clipboard.Clear(); chatBox.Cut(); } private void pasteToolStripMenuItem_Click(object sender, EventArgs e) { chatBox.AppendText(Clipboard.GetText()); } }}Form3.cs//code for error messageusing System;using System.Collections.Generic;using System.ComponentModel;
36. using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Windows.Forms;namespace Chat_App{ public partial class Form3 : Form { public Form3() { InitializeComponent(); } private void label1_Click(object sender, EventArgs e) { } private void button1_Click(object sender, EventArgs e) { Form3.ActiveForm.Close(); } }}
37. APPENDIX [B] OutputOne of the most important principles of Software Design is to keep the software simple yet effective. Thishas been the guiding force during the design phase of our software. And the Interface that we provide isno exception. Against the backdrop of this ideology we design a simple yet very effective interface. Ad-Hoc